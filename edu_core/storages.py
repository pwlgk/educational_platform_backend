import os
from django.core.files.storage import FileSystemStorage
from django.conf import settings
from django.utils.deconstruct import deconstructible

# Декоратор @deconstructible необходим для того, чтобы класс хранилища
# мог быть сериализован в миграциях Django.

# Класс OverwriteKeepOriginalNameStorage представляет собой кастомное файловое хранилище,
# которое наследуется от стандартного FileSystemStorage Django.
# Его основная особенность заключается в том, что при сохранении файла, если файл
# с таким же именем уже существует в указанном пути, он будет перезаписан.
# Оригинальное имя файла при этом сохраняется (Django не добавляет случайные символы к имени).
#
# Предупреждение: Использовать это хранилище следует с осторожностью, так как
# существующие файлы будут безвозвратно перезаписаны. Оно подходит для ситуаций,
# когда функция `upload_to` (определяющая путь сохранения файла для поля модели)
# уже гарантирует уникальность пути для каждого сохраняемого файла (например,
# путь включает ID объекта или UUID), и требуется, чтобы имя файла оставалось
# оригинальным.
#
# Метод `get_available_name(self, name, max_length=None)`:
#   - Переопределяет стандартное поведение Django по генерации уникального имени файла.
#   - Если файл с именем `name` уже существует, он сначала удаляется из файловой системы.
#   - Затем метод возвращает оригинальное имя `name`, что приводит к сохранению
#     нового файла под этим именем, фактически перезаписывая старый.
@deconstructible
class OverwriteKeepOriginalNameStorage(FileSystemStorage):
    def get_available_name(self, name, max_length=None):
        if self.exists(name):
            try:
                os.remove(os.path.join(settings.MEDIA_ROOT, name))
            except OSError as e:
                # Логирование ошибки удаления файла, если это необходимо
                # logger.error(f"Error removing file {name} before overwrite: {e}")
                pass # Продолжаем, пытаясь сохранить файл
        return name

# Класс KeepOriginalNameIfNotExistsStorage также наследуется от FileSystemStorage.
# Это хранилище пытается сохранить оригинальное имя файла, но только в том случае,
# если файл с таким именем еще не существует по указанному пути.
# Если файл с таким именем уже существует, это хранилище делегирует генерацию
# нового, уникального имени стандартному поведению FileSystemStorage (обычно
# Django добавляет случайный суффикс к имени файла).
#
# Этот подход является более безопасным, чем полная перезапись (как в
# OverwriteKeepOriginalNameStorage), так как он предотвращает случайную потерю данных.
# Однако он не гарантирует, что файл всегда будет сохранен под своим оригинальным именем.
#
# Метод `get_available_name(self, name, max_length=None)`:
#   - Проверяет, существует ли файл с именем `name`.
#   - Если файл существует, вызывает `super().get_available_name(name, max_length)`,
#     чтобы Django сгенерировал уникальное имя.
#   - Если файл не существует, возвращает оригинальное имя `name`.
@deconstructible
class KeepOriginalNameIfNotExistsStorage(FileSystemStorage):
    def get_available_name(self, name, max_length=None):
        if self.exists(name):
            return super().get_available_name(name, max_length)
        return name

# Класс UniquePathAndOriginalNameStorage представляет собой хранилище, которое
# нацелено на сохранение оригинального имени файла, полагаясь на то, что функция `upload_to`
# (для поля FileField/ImageField модели) формирует уникальный путь (директорию)
# для каждого объекта или контекста загрузки.
#
# Принцип работы:
#   Метод `get_available_name` просто возвращает переданное ему имя `name`.
#   Предполагается, что функция `upload_to` модели уже создала уникальную
#   директорию для сохранения файла (например, `media/user_avatars/user_123/` или
#   `media/homework_attachments/homework_42/submission_7/`).
#   Если в этой (предположительно уникальной) директории файл с точно таким же
#   именем все же существует, то стандартное поведение `FileSystemStorage` (от которого
#   наследуется этот класс) приведет к тому, что Django добавит суффикс к имени файла
#   для обеспечения уникальности на уровне файловой системы.
#
#   Этот вариант является компромиссом: он не перезаписывает файлы без разбора,
#   но и не гарантирует сохранение оригинального имени в 100% случаев, если
#   `upload_to` не обеспечивает абсолютную уникальность пути + имени файла.
#   Он хорошо подходит, если `upload_to` генерирует пути типа
#   `.../object_id/original_filename.ext` или `.../uuid.ext`, где коллизии
#   маловероятны или обрабатываются на уровне генерации пути.
@deconstructible
class UniquePathAndOriginalNameStorage(FileSystemStorage):
    def get_available_name(self, name, max_length=None):
        # Просто возвращаем имя. Если файл с таким именем уже существует
        # в этой директории, FileSystemStorage (родительский класс)
        # добавит суффикс для обеспечения уникальности.
        # Логика создания уникального пути должна быть в функции upload_to модели.
        return name